<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ursinho vs Fantasminha</title>
  <style>
    html,body{height:100%;margin:0}
    body { background:#1b1f2a; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    canvas { display:block; background:#0e1220; }
    .hud{position:fixed;left:12px;top:12px;background:rgba(0,0,0,.35);backdrop-filter:blur(6px);color:#e6eaf6;padding:8px 10px;border-radius:10px;font-size:14px}
    .hud b{color:#86efac}
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div class="hud">Controles: <b>WASD</b> (ou setas). Evite o fantasma!</div>

  <script>
  (function(){
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    function resize(){
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize, {passive:true});
    resize();

    // ===== ENTIDADES =====
    const bear = { x: 160, y: 140, r: 22, speed: 3.6 };
    const ghost = { x: 420, y: 380, r: 22, speed: 2.3 };

    // ===== OBSTÁCULOS =====
    const obstacles = [
      // horizontais
      { x: 180, y: 140, w: 160, h: 26 },
      { x: 420, y: 200, w: 240, h: 26 },
      { x: 720, y: 120, w: 220, h: 26 },
      { x: 980, y: 260, w: 200, h: 26 },
      { x: 260, y: 420, w: 220, h: 26 },
      { x: 620, y: 520, w: 280, h: 26 },
      { x: 100, y: 300, w: 160, h: 26 },
      { x: 900, y: 460, w: 220, h: 26 },
      // verticais
      { x: 360, y: 240, w: 26, h: 200 },
      { x: 640, y: 160, w: 26, h: 240 },
      { x: 860, y: 320, w: 26, h: 220 },
      { x: 520, y: 380, w: 26, h: 220 },
      { x: 180, y: 480, w: 26, h: 180 },
      // pilares
      { x: 780, y: 260, w: 36, h: 36 },
      { x: 500, y: 120, w: 36, h: 36 },
      { x: 320, y: 540, w: 36, h: 36 }
    ];

    // ===== INPUT (WASD/Setas) =====
    const keys = { w:false, a:false, s:false, d:false, ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false };
    addEventListener('keydown', (e)=>{
      const k = e.key;
      if (k in keys || "wasd".includes(k.toLowerCase())) { 
        const kl = k.toLowerCase();
        if (kl === 'w') keys.w = true;
        if (kl === 'a') keys.a = true;
        if (kl === 's') keys.s = true;
        if (kl === 'd') keys.d = true;
        if (k in keys) keys[k] = true;
        e.preventDefault();
      }
    });
    addEventListener('keyup', (e)=>{
      const k = e.key;
      if (k in keys || "wasd".includes(k.toLowerCase())) { 
        const kl = k.toLowerCase();
        if (kl === 'w') keys.w = false;
        if (kl === 'a') keys.a = false;
        if (kl === 's') keys.s = false;
        if (kl === 'd') keys.d = false;
        if (k in keys) keys[k] = false;
        e.preventDefault();
      }
    });

    // ===== SPRITES =====
    function makeCanvas(w,h){ const c=document.createElement('canvas'); c.width=w; c.height=h; return c; }

    function createBearSprite(size){
      const c = makeCanvas(size,size);
      const g = c.getContext('2d');
      const r = size*0.45; const cx=size/2, cy=size/2;
      const grad = g.createRadialGradient(cx,cy,r*0.4, cx,cy,r);
      grad.addColorStop(0,'#b8f7c2'); grad.addColorStop(1,'#39a96b');
      g.fillStyle = grad; g.beginPath(); g.arc(cx,cy,r,0,Math.PI*2); g.fill();
      g.fillStyle = 'rgba(255,255,255,.9)';
      g.beginPath(); g.arc(cx - r*0.6, cy - r*0.7, r*0.35, 0, Math.PI*2); g.fill();
      g.beginPath(); g.arc(cx + r*0.6, cy - r*0.7, r*0.35, 0, Math.PI*2); g.fill();
      g.fillStyle = '#0a0f25';
      g.beginPath(); g.arc(cx - r*0.35, cy - r*0.1, r*0.15, 0, Math.PI*2); g.fill();
      g.beginPath(); g.arc(cx + r*0.35, cy - r*0.1, r*0.15, 0, Math.PI*2); g.fill();
      g.fillStyle = '#0b122d'; g.beginPath(); g.arc(cx, cy + r*0.15, r*0.18, 0, Math.PI*2); g.fill();
      return c;
    }

    function createGhostSprite(size){
      const c = makeCanvas(size,size);
      const g = c.getContext('2d');
      const r = size*0.42; const cx=size/2, cy=size/2;
      const glow = g.createRadialGradient(cx,cy,r*0.6, cx,cy,r*2.2);
      glow.addColorStop(0,'rgba(255,255,255,0.35)'); glow.addColorStop(1,'rgba(255,255,255,0)');
      g.fillStyle = glow; g.beginPath(); g.arc(cx,cy,r*2,0,Math.PI*2); g.fill();
      g.fillStyle = '#e9ecff'; g.beginPath();
      g.moveTo(cx - r, cy);
      g.quadraticCurveTo(cx - r, cy - r*1.2, cx, cy - r*1.4);
      g.quadraticCurveTo(cx + r, cy - r*1.2, cx + r, cy);
      const waves = 5; const step = (2*r)/waves;
      for(let i=0;i<waves;i++){
        const sx = cx + r - i*step; const dir = (i%2===0)?1:-1;
        g.quadraticCurveTo(sx - step/2, cy + r*0.9 + dir*3, sx - step, cy);
      }
      g.closePath(); g.fill();
      g.fillStyle = '#0a0f25';
      g.beginPath(); g.arc(cx - r*0.35, cy - r*0.2, r*0.18, 0, Math.PI*2); g.fill();
      g.beginPath(); g.arc(cx + r*0.35, cy - r*0.2, r*0.18, 0, Math.PI*2); g.fill();
      return c;
    }

    const bearSprite = createBearSprite(64);
    const ghostSprite = createGhostSprite(64);

    // ===== COLISÃO =====
    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
    function circleRectCollide(cx,cy,cr, r){
      const nx = clamp(cx, r.x, r.x + r.w);
      const ny = clamp(cy, r.y, r.y + r.h);
      const dx = cx - nx; const dy = cy - ny;
      return (dx*dx + dy*dy) < (cr*cr);
    }

    // ===== LÓGICA =====
    function moveBear(){
      let vx = (keys.d||keys.ArrowRight?1:0) - (keys.a||keys.ArrowLeft?1:0);
      let vy = (keys.s||keys.ArrowDown?1:0) - (keys.w||keys.ArrowUp?1:0);
      if(vx||vy){
        const len = Math.hypot(vx,vy) || 1; vx/=len; vy/=len;
        const nextX = bear.x + vx*bear.speed;
        const nextY = bear.y + vy*bear.speed;
        // X
        let blockedX=false;
        for(const o of obstacles){ if(circleRectCollide(nextX, bear.y, bear.r, o)){ blockedX=true; break; } }
        if(!blockedX) bear.x = nextX;
        // Y
        let blockedY=false;
        for(const o of obstacles){ if(circleRectCollide(bear.x, nextY, bear.r, o)){ blockedY=true; break; } }
        if(!blockedY) bear.y = nextY;
      }
      bear.x = clamp(bear.x, bear.r, canvas.width  - bear.r);
      bear.y = clamp(bear.y, bear.r, canvas.height - bear.r);
    }

    function moveGhost(){
      const dx = bear.x - ghost.x; const dy = bear.y - ghost.y;
      const d = Math.hypot(dx,dy) || 1;
      const step = Math.min(ghost.speed, d);
      ghost.x += (dx/d)*step; ghost.y += (dy/d)*step; // atravessa obstáculos
    }

    // ===== DESENHO =====
    function drawObstacles(){
      for(const o of obstacles){
        const grad = ctx.createLinearGradient(o.x,o.y,o.x+o.w,o.y+o.h);
        grad.addColorStop(0,'#263056'); grad.addColorStop(1,'#1a2244');
        ctx.fillStyle = grad; ctx.fillRect(o.x,o.y,o.w,o.h);
        ctx.strokeStyle = 'rgba(255,255,255,.08)'; ctx.lineWidth=2; ctx.strokeRect(o.x+.5,o.y+.5,o.w-1,o.h-1);
      }
    }
    function drawEntities(){
      ctx.drawImage(ghostSprite, ghost.x - ghost.r*1.6, ghost.y - ghost.r*1.6);
      ctx.drawImage(bearSprite,  bear.x  - bear.r*1.6,  bear.y  - bear.r*1.6);
    }
    function drawBG(){
      const g = ctx.createLinearGradient(0,0,0,canvas.height);
      g.addColorStop(0,'#0f1328'); g.addColorStop(1,'#0b0f22');
      ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    function frame(){
      moveBear();
      moveGhost();
      drawBG();
      drawObstacles();
      drawEntities();
      requestAnimationFrame(frame);
    }

    // Start
    requestAnimationFrame(frame);
  })();
  </script>
</body>
</html>
